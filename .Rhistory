Names$short <- paste(substr(Names$FirstName, 1, 4), Names$LastName, sep=' ')
cols <- grep('^.*(Name)$', names(Friends))
cols <- cols[c(-1,-2)]
for (i in cols){
friendsplit <- strsplit(as.character(Friends[,i]), ' ')
a<-friendsplit[lapply(friendsplit, length)==2]
friend.first<-substr(tolower(unlist(lapply(a, '[[', 1))), 1, 4)
friend.last<-tolower(unlist(lapply(a, '[[', 2)))
friendname.short <- paste(friend.first, friend.last, sep=' ')
friendname.full <- paste(tolower(unlist(lapply(a, '[[', 1))), friend.last, sep=' ')
df.1<-data.frame(first=friend.first, last=friend.last, short=friendname.short,
loc=which(lapply(friendsplit,length)==2))
df.2<-join(df.1, Names)
df.2<-na.omit(df.2)
b<-as.character(Friends[,i])
b[df.2$loc]<-as.character(df.2$PPID)
Friends[,i]<-b
}
write.csv(Friends, file='deidentified.csv')
Names<-read.csv('PPIDName-LinkingFile.csv')
head(Names)
setwd("~/Documents/Gits/StatsWorkshop")
source('~/.active-rstudio-document', echo=TRUE)
install.packages('VennDiagram')
library(VennDiagram)
venn.plot <- draw.triple.venn(10, 10, 10, 2, 2, 2, 2)
grid.newpage()
venn.plot <- draw.triple.venn(10, 10, 10, 2, 2, 2, 2)
venn.plot <- draw.triple.venn(10, 10, 10, 2, 2, 2, 1)
venn.plot <- draw.triple.venn(10, 10, 5, 2, 2, 2, 1)
venn.plot <- draw.triple.venn(10, 10, 10, 2, 2, 2)
venn.plot <- draw.triple.venn(10, 10, 10, 2, 2, 2, 2)
grid.newpage
grid.newpage()
venn.plot <- draw.triple.venn(10, 10, 10, 2, 2, 2, 2, category = c('Prime', 'Attitude', 'Prime*Attitude'))
fill=c('blue', 'red', 'green')
venn.plot <- draw.triple.venn(10, 10, 10, 2, 2, 2, 2, category = c('Prime', 'Attitude', 'Prime*Attitude'), fill='blue', 'red', 'green')
venn.plot <- draw.triple.venn(10, 10, 10, 2, 2, 2, 2, category = c('Prime', 'Attitude', 'Prime*Attitude'), fill=c('blue', 'red', 'green'))
install.packages('colorfulVennPlot')
library(colorfulVennPlot)
plotvenn(c(10, 10, 10, 10, 10, 10, 10))
plotVenn(c(10, 10, 10, 10, 10, 10, 10))
grid.newpage()
plotVenn(c(10, 10, 10, 10, 10, 10, 5))
grid.newpage()
plotVenn(c(10, 10, 10, 10, 10, 1, 57))
grid.newpage()
plotVenn(c(10, 10, 10, 10, 5, 1, 57))
plotVenn(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'))
grid.newpage()
plotVenn(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), colors = c('red', 'blue', 'orange', 'purprle'))
plotVenn(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purprle'))
plotVenn(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purple'))
plotVenn(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purple', 'green'))
plotVenn(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purple', 'green', 'grey'))
plotVenn(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purple', 'green', 'grey', 'white'))
plot.new()
Colors <- c('red', 'yellow', 'green', 'pink', 'darkgreen','blue','lightblue','tan',
'yellowgreen','orange','purple','white','grey','plum','brown')
regions <- seq(15)
names(regions) <- c('1000', '0100', '1100', '0010', '1010', '0110', '1110', '0001',
'1001', '0101', '1101', '0011', '1011', '0111', '1111')
plotVenn4d(regions, Colors=Colors, Title = '4-dimensional')
plotVenn
plotVenn3d
plotVenn3d.novals <- function (x, labels = c("A", "B", "C"), Colors = c("red", "yellow",
"orange", "lightblue", "purple", "green", "grey"), Title = NULL,
shrink = 1, rot = 0)
{
getArcEnds <- function(center1, center2, radius) {
calcdist <- function(x, y) sqrt((x[1] - y[1])^2 + (x[2] -
y[2])^2)
calcangle <- function(x, y) atan((y[2] - x[2])/(y[1] -
x[1]))
centerDistance <- calcdist(center1, center2)
connector <- ifelse(center1[1] > center2[1], pi, 0) +
calcangle(center1, center2)
intersection <- acos((centerDistance/2)/radius)
c(begin = connector - intersection, end = connector +
intersection)
}
arcPoints <- function(beginpt, endpt, center, radius) {
angles <- seq(beginpt, endpt, length = nfacets)
x <- center[1] + radius * cos(angles)
y <- center[2] + radius * sin(angles)
list(x = x, y = y)
}
getArc <- function(center1, center2, radius) {
ends <- getArcEnds(center1, center2, radius)
arcPoints(ends["begin"], ends["end"], center1, radius)
}
twoWayOverlap <- function(center1, center2, radius, color) {
points1 <- getArc(center1, center2, radius)
points2 <- getArc(center2, center1, radius)
points <- list()
points$x <- c(points1$x, points2$x)
points$y <- c(points1$y, points2$y)
grid.polygon(x = points$x, y = points$y, gp = gpar(fill = color))
}
centralArcs <- function(centers, i, radius) {
if (i == 1) {
j <- 2
k <- 3
}
if (i == 2) {
j <- 1
k <- 3
}
if (i == 3) {
j <- 2
k <- 1
}
endsone <- getArcEnds(centers[[i]], centers[[j]], radius)
endstwo <- getArcEnds(centers[[i]], centers[[k]], radius)
if (endsone[2] < 0)
endsone <- endsone + 2 * pi
if (endstwo[2] < 0)
endstwo <- endstwo + 2 * pi
if (endstwo[1] < endsone[1] & endsone[1] < endstwo[2]) {
return(arcPoints(endsone[1], endstwo[2], centers[[i]],
radius))
}
else {
return(arcPoints(endstwo[1], endsone[2], centers[[i]],
radius))
}
}
fromBase2 <- function(x) 4 * as.numeric(substr(x, 1, 1)) +
2 * as.numeric(substr(x, 2, 2)) + as.numeric(substr(x,
3, 3))
rotateCoordinates <- function(xy, tiltpi) {
if (is.null(nrow(xy)))
adjustCenter <- plotCenter
else adjustCenter <- matrix(rep(plotCenter, nrow(xy)),
byrow = TRUE, nrow = nrow(xy))
rotationMatrix <- matrix(c(cos(tiltpi), -sin(tiltpi),
sin(tiltpi), cos(tiltpi)), byrow = TRUE, ncol = 2)
(xy - adjustCenter) %*% rotationMatrix + adjustCenter
}
rot <- rot%%360
tiltpi <- rot * pi/180
if (missing(x))
x <- paste(seq(15), Colors)
values <- rep(0, length(x))
if (is.null(names(x)))
names(x) <- c("101", "110", "010", "001", "011", "100",
"111")[seq(length(x))]
valptr <- unlist(lapply(names(x), fromBase2))
inputColors <- Colors
for (i in seq_along(x)) if (valptr[i] %in% 1:7) {
values[valptr[i]] <- values[valptr[i]] + x[i]
Colors[valptr[i]] <- inputColors[i]
}
nfacets <- 300
radius <- 0.25
r0 <- 0.18
dy <- r0 * sin(pi/6)
dx <- r0 * cos(pi/6)
labx0 <- 0.29
labx1 <- 1.5
labx2 <- 0.75
plotCenter <- c(0.5, ifelse(is.null(Title), 0.5, 0.43))
centers <- list(c(plotCenter[1], plotCenter[2] + r0), c(plotCenter[1] -
dx, plotCenter[2] - dy), c(plotCenter[1] + dx, plotCenter[2] -
dy))
angle <- seq(0, 2 * pi, length = nfacets)[-nfacets]
points1 <- centralArcs(centers, 1, radius)
points2 <- centralArcs(centers, 2, radius)
points3 <- centralArcs(centers, 3, radius)
points <- list()
points$x <- c(points1$x, points2$x, points3$x)
points$y <- c(points1$y, points2$y, points3$y)
if (tiltpi != 0) {
pointsxy <- rotateCoordinates(cbind(points$x, points$y),
tiltpi)
points$x <- pointsxy[, 1]
points$y <- pointsxy[, 2]
centers <- sapply(centers, function(x) list(rotateCoordinates(x,
tiltpi)))
}
labelLocations <- rotateCoordinates(matrix(c(plotCenter[1],
plotCenter[2] + r0 + labx0, plotCenter[1] - dx, plotCenter[2] -
dy - labx0, plotCenter[1] + dx, plotCenter[2] - dy -
labx0), byrow = TRUE, ncol = 2), tiltpi)
centerLocations <- rotateCoordinates(matrix(c(plotCenter[1] +
dx * labx1, plotCenter[2] - dy * labx1, plotCenter[1] -
dx * labx1, plotCenter[2] - dy * labx1, plotCenter[1],
plotCenter[2] - r0 * labx2, plotCenter[1], plotCenter[2] +
r0 * labx1, plotCenter[1] + dx * labx2, plotCenter[2] +
dy * labx2, plotCenter[1] - dx * labx2, plotCenter[2] +
dy * labx2, plotCenter[1], plotCenter[2]), byrow = TRUE,
ncol = 2), tiltpi)
if (!is.null(Title))
grid.text(Title, gp = gpar(fontsize = 25 * shrink, fontface = "bold"),
x = plotCenter[1], y = 0.97)
grid.polygon(x = centers[[1]][1] + radius * cos(angle), y = centers[[1]][2] +
radius * sin(angle), gp = gpar(fill = Colors[4]))
grid.polygon(x = centers[[2]][1] + radius * cos(angle), y = centers[[2]][2] +
radius * sin(angle), gp = gpar(fill = Colors[2]))
grid.polygon(x = centers[[3]][1] + radius * cos(angle), y = centers[[3]][2] +
radius * sin(angle), gp = gpar(fill = Colors[1]))
twoWayOverlap(centers[[1]], centers[[2]], radius, Colors[6])
twoWayOverlap(centers[[2]], centers[[3]], radius, Colors[3])
twoWayOverlap(centers[[1]], centers[[3]], radius, Colors[5])
grid.polygon(x = points$x, y = points$y, gp = gpar(fill = Colors[7]))
for (i in 1:3) grid.text(labels[i], labelLocations[i, 1],
labelLocations[i, 2], gp = gpar(fontsize = 18 * shrink,
fontface = "bold"))
}
plotVenn3d.novals(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purple', 'green', 'grey', 'white'))
new.grid()
grid.newpage()
plotVenn3d.novals(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purple', 'green', 'grey', 'white'))
plotVenn3d.novals <- function (x, labels = c("A", "B", "C"), Colors = c("red", "yellow",
"orange", "lightblue", "purple", "green", "grey"), Title = NULL,
shrink = 1, rot = 0)
{
getArcEnds <- function(center1, center2, radius) {
calcdist <- function(x, y) sqrt((x[1] - y[1])^2 + (x[2] -
y[2])^2)
calcangle <- function(x, y) atan((y[2] - x[2])/(y[1] -
x[1]))
centerDistance <- calcdist(center1, center2)
connector <- ifelse(center1[1] > center2[1], pi, 0) +
calcangle(center1, center2)
intersection <- acos((centerDistance/2)/radius)
c(begin = connector - intersection, end = connector +
intersection)
}
arcPoints <- function(beginpt, endpt, center, radius) {
angles <- seq(beginpt, endpt, length = nfacets)
x <- center[1] + radius * cos(angles)
y <- center[2] + radius * sin(angles)
list(x = x, y = y)
}
getArc <- function(center1, center2, radius) {
ends <- getArcEnds(center1, center2, radius)
arcPoints(ends["begin"], ends["end"], center1, radius)
}
twoWayOverlap <- function(center1, center2, radius, color) {
points1 <- getArc(center1, center2, radius)
points2 <- getArc(center2, center1, radius)
points <- list()
points$x <- c(points1$x, points2$x)
points$y <- c(points1$y, points2$y)
grid.polygon(x = points$x, y = points$y, gp = gpar(fill = color))
}
centralArcs <- function(centers, i, radius) {
if (i == 1) {
j <- 2
k <- 3
}
if (i == 2) {
j <- 1
k <- 3
}
if (i == 3) {
j <- 2
k <- 1
}
endsone <- getArcEnds(centers[[i]], centers[[j]], radius)
endstwo <- getArcEnds(centers[[i]], centers[[k]], radius)
if (endsone[2] < 0)
endsone <- endsone + 2 * pi
if (endstwo[2] < 0)
endstwo <- endstwo + 2 * pi
if (endstwo[1] < endsone[1] & endsone[1] < endstwo[2]) {
return(arcPoints(endsone[1], endstwo[2], centers[[i]],
radius))
}
else {
return(arcPoints(endstwo[1], endsone[2], centers[[i]],
radius))
}
}
fromBase2 <- function(x) 4 * as.numeric(substr(x, 1, 1)) +
2 * as.numeric(substr(x, 2, 2)) + as.numeric(substr(x,
3, 3))
rotateCoordinates <- function(xy, tiltpi) {
if (is.null(nrow(xy)))
adjustCenter <- plotCenter
else adjustCenter <- matrix(rep(plotCenter, nrow(xy)),
byrow = TRUE, nrow = nrow(xy))
rotationMatrix <- matrix(c(cos(tiltpi), -sin(tiltpi),
sin(tiltpi), cos(tiltpi)), byrow = TRUE, ncol = 2)
(xy - adjustCenter) %*% rotationMatrix + adjustCenter
}
rot <- rot%%360
tiltpi <- rot * pi/180
if (missing(x))
x <- paste(seq(15), Colors)
values <- rep(0, length(x))
if (is.null(names(x)))
names(x) <- c("101", "110", "010", "001", "011", "100",
"111")[seq(length(x))]
valptr <- unlist(lapply(names(x), fromBase2))
inputColors <- Colors
for (i in seq_along(x)) if (valptr[i] %in% 1:7) {
values[valptr[i]] <- values[valptr[i]] + x[i]
Colors[valptr[i]] <- inputColors[i]
}
nfacets <- 300
radius <- 0.25
r0 <- 0.18
dy <- r0 * sin(pi/6)
dx <- r0 * cos(pi/6)
labx0 <- 0.29
labx1 <- 1.5
labx2 <- 0.75
plotCenter <- c(0.5, ifelse(is.null(Title), 0.5, 0.43))
centers <- list(c(plotCenter[1], plotCenter[2] + r0), c(plotCenter[1] -
dx, plotCenter[2] - dy), c(plotCenter[1] + dx, plotCenter[2] -
dy))
angle <- seq(0, 2 * pi, length = nfacets)[-nfacets]
points1 <- centralArcs(centers, 1, radius)
points2 <- centralArcs(centers, 2, radius)
points3 <- centralArcs(centers, 3, radius)
points <- list()
points$x <- c(points1$x, points2$x, points3$x)
points$y <- c(points1$y, points2$y, points3$y)
if (tiltpi != 0) {
pointsxy <- rotateCoordinates(cbind(points$x, points$y),
tiltpi)
points$x <- pointsxy[, 1]
points$y <- pointsxy[, 2]
centers <- sapply(centers, function(x) list(rotateCoordinates(x,
tiltpi)))
}
labelLocations <- rotateCoordinates(matrix(c(plotCenter[1],
plotCenter[2] + r0 + labx0, plotCenter[1] - dx, plotCenter[2] -
dy - labx0, plotCenter[1] + dx, plotCenter[2] - dy -
labx0), byrow = TRUE, ncol = 2), tiltpi)
centerLocations <- rotateCoordinates(matrix(c(plotCenter[1] +
dx * labx1, plotCenter[2] - dy * labx1, plotCenter[1] -
dx * labx1, plotCenter[2] - dy * labx1, plotCenter[1],
plotCenter[2] - r0 * labx2, plotCenter[1], plotCenter[2] +
r0 * labx1, plotCenter[1] + dx * labx2, plotCenter[2] +
dy * labx2, plotCenter[1] - dx * labx2, plotCenter[2] +
dy * labx2, plotCenter[1], plotCenter[2]), byrow = TRUE,
ncol = 2), tiltpi)
if (!is.null(Title))
grid.text(Title, gp = gpar(fontsize = 25 * shrink, fontface = "bold"),
x = plotCenter[1], y = 0.97)
grid.polygon(x = centers[[1]][1] + radius * cos(angle), y = centers[[1]][2] +
radius * sin(angle), gp = gpar(fill = Colors[4]))
grid.polygon(x = centers[[2]][1] + radius * cos(angle), y = centers[[2]][2] +
radius * sin(angle), gp = gpar(fill = Colors[2]))
grid.polygon(x = centers[[3]][1] + radius * cos(angle), y = centers[[3]][2] +
radius * sin(angle), gp = gpar(fill = Colors[1]))
twoWayOverlap(centers[[1]], centers[[2]], radius, Colors[6])
twoWayOverlap(centers[[2]], centers[[3]], radius, Colors[3])
twoWayOverlap(centers[[1]], centers[[3]], radius, Colors[5])
grid.polygon(x = points$x, y = points$y, gp = gpar(fill = Colors[7]))
for (i in 1:3) grid.text(labels[i], labelLocations[i, 1],
labelLocations[i, 2], gp = gpar(fontsize = 18 * shrink,
fontface = "bold"))
if(isTRUE(printvals)){
for (i in 1:7) grid.text(values[i], centerLocations[i, 1],
centerLocations[i, 2])
}
}
plotVenn3d.novals(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purple', 'green', 'grey', 'white'))
plotVenn3d.novals <- function (x, labels = c("A", "B", "C"), Colors = c("red", "yellow",
"orange", "lightblue", "purple", "green", "grey"), Title = NULL,
shrink = 1, rot = 0, printvals=TRUE)
{
getArcEnds <- function(center1, center2, radius) {
calcdist <- function(x, y) sqrt((x[1] - y[1])^2 + (x[2] -
y[2])^2)
calcangle <- function(x, y) atan((y[2] - x[2])/(y[1] -
x[1]))
centerDistance <- calcdist(center1, center2)
connector <- ifelse(center1[1] > center2[1], pi, 0) +
calcangle(center1, center2)
intersection <- acos((centerDistance/2)/radius)
c(begin = connector - intersection, end = connector +
intersection)
}
arcPoints <- function(beginpt, endpt, center, radius) {
angles <- seq(beginpt, endpt, length = nfacets)
x <- center[1] + radius * cos(angles)
y <- center[2] + radius * sin(angles)
list(x = x, y = y)
}
getArc <- function(center1, center2, radius) {
ends <- getArcEnds(center1, center2, radius)
arcPoints(ends["begin"], ends["end"], center1, radius)
}
twoWayOverlap <- function(center1, center2, radius, color) {
points1 <- getArc(center1, center2, radius)
points2 <- getArc(center2, center1, radius)
points <- list()
points$x <- c(points1$x, points2$x)
points$y <- c(points1$y, points2$y)
grid.polygon(x = points$x, y = points$y, gp = gpar(fill = color))
}
centralArcs <- function(centers, i, radius) {
if (i == 1) {
j <- 2
k <- 3
}
if (i == 2) {
j <- 1
k <- 3
}
if (i == 3) {
j <- 2
k <- 1
}
endsone <- getArcEnds(centers[[i]], centers[[j]], radius)
endstwo <- getArcEnds(centers[[i]], centers[[k]], radius)
if (endsone[2] < 0)
endsone <- endsone + 2 * pi
if (endstwo[2] < 0)
endstwo <- endstwo + 2 * pi
if (endstwo[1] < endsone[1] & endsone[1] < endstwo[2]) {
return(arcPoints(endsone[1], endstwo[2], centers[[i]],
radius))
}
else {
return(arcPoints(endstwo[1], endsone[2], centers[[i]],
radius))
}
}
fromBase2 <- function(x) 4 * as.numeric(substr(x, 1, 1)) +
2 * as.numeric(substr(x, 2, 2)) + as.numeric(substr(x,
3, 3))
rotateCoordinates <- function(xy, tiltpi) {
if (is.null(nrow(xy)))
adjustCenter <- plotCenter
else adjustCenter <- matrix(rep(plotCenter, nrow(xy)),
byrow = TRUE, nrow = nrow(xy))
rotationMatrix <- matrix(c(cos(tiltpi), -sin(tiltpi),
sin(tiltpi), cos(tiltpi)), byrow = TRUE, ncol = 2)
(xy - adjustCenter) %*% rotationMatrix + adjustCenter
}
rot <- rot%%360
tiltpi <- rot * pi/180
if (missing(x))
x <- paste(seq(15), Colors)
values <- rep(0, length(x))
if (is.null(names(x)))
names(x) <- c("101", "110", "010", "001", "011", "100",
"111")[seq(length(x))]
valptr <- unlist(lapply(names(x), fromBase2))
inputColors <- Colors
for (i in seq_along(x)) if (valptr[i] %in% 1:7) {
values[valptr[i]] <- values[valptr[i]] + x[i]
Colors[valptr[i]] <- inputColors[i]
}
nfacets <- 300
radius <- 0.25
r0 <- 0.18
dy <- r0 * sin(pi/6)
dx <- r0 * cos(pi/6)
labx0 <- 0.29
labx1 <- 1.5
labx2 <- 0.75
plotCenter <- c(0.5, ifelse(is.null(Title), 0.5, 0.43))
centers <- list(c(plotCenter[1], plotCenter[2] + r0), c(plotCenter[1] -
dx, plotCenter[2] - dy), c(plotCenter[1] + dx, plotCenter[2] -
dy))
angle <- seq(0, 2 * pi, length = nfacets)[-nfacets]
points1 <- centralArcs(centers, 1, radius)
points2 <- centralArcs(centers, 2, radius)
points3 <- centralArcs(centers, 3, radius)
points <- list()
points$x <- c(points1$x, points2$x, points3$x)
points$y <- c(points1$y, points2$y, points3$y)
if (tiltpi != 0) {
pointsxy <- rotateCoordinates(cbind(points$x, points$y),
tiltpi)
points$x <- pointsxy[, 1]
points$y <- pointsxy[, 2]
centers <- sapply(centers, function(x) list(rotateCoordinates(x,
tiltpi)))
}
labelLocations <- rotateCoordinates(matrix(c(plotCenter[1],
plotCenter[2] + r0 + labx0, plotCenter[1] - dx, plotCenter[2] -
dy - labx0, plotCenter[1] + dx, plotCenter[2] - dy -
labx0), byrow = TRUE, ncol = 2), tiltpi)
centerLocations <- rotateCoordinates(matrix(c(plotCenter[1] +
dx * labx1, plotCenter[2] - dy * labx1, plotCenter[1] -
dx * labx1, plotCenter[2] - dy * labx1, plotCenter[1],
plotCenter[2] - r0 * labx2, plotCenter[1], plotCenter[2] +
r0 * labx1, plotCenter[1] + dx * labx2, plotCenter[2] +
dy * labx2, plotCenter[1] - dx * labx2, plotCenter[2] +
dy * labx2, plotCenter[1], plotCenter[2]), byrow = TRUE,
ncol = 2), tiltpi)
if (!is.null(Title))
grid.text(Title, gp = gpar(fontsize = 25 * shrink, fontface = "bold"),
x = plotCenter[1], y = 0.97)
grid.polygon(x = centers[[1]][1] + radius * cos(angle), y = centers[[1]][2] +
radius * sin(angle), gp = gpar(fill = Colors[4]))
grid.polygon(x = centers[[2]][1] + radius * cos(angle), y = centers[[2]][2] +
radius * sin(angle), gp = gpar(fill = Colors[2]))
grid.polygon(x = centers[[3]][1] + radius * cos(angle), y = centers[[3]][2] +
radius * sin(angle), gp = gpar(fill = Colors[1]))
twoWayOverlap(centers[[1]], centers[[2]], radius, Colors[6])
twoWayOverlap(centers[[2]], centers[[3]], radius, Colors[3])
twoWayOverlap(centers[[1]], centers[[3]], radius, Colors[5])
grid.polygon(x = points$x, y = points$y, gp = gpar(fill = Colors[7]))
for (i in 1:3) grid.text(labels[i], labelLocations[i, 1],
labelLocations[i, 2], gp = gpar(fontsize = 18 * shrink,
fontface = "bold"))
if(isTRUE(printvals)){
for (i in 1:7) grid.text(values[i], centerLocations[i, 1],
centerLocations[i, 2])
}
}
plotVenn3d.novals(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purple', 'green', 'grey', 'white'))
plotVenn3d.novals(c(10, 10, 10, 10, 5, 1, 57), labels = c('Prime', 'Attitude', 'Prime*Attitude'), Colors = c('red', 'blue', 'orange', 'purple', 'green', 'grey', 'white'), printvals=F)
